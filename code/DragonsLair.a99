** remember to debug with 'break on illegal opcode' so we can find bad tables
** remember to debug with 'break on illegal opcode' so we can find bad tables

**************
* Dragon's Lair for the TI-99/4A - by M.Brent aka Tursi
* A big extension of my AV Playback code, as below
* Licensed by Digital Leisure - holy crap!
* A real licensed release of a major property in 2017... I mean 2018...
* I mean 2019. Damn it. ;)
**************
* Fixed for: sound chip timing
*            gigacart switching (14-bits worth - 128MB)
*
* Each frame has 6144 bytes of video, and 1544 bytes of audio.
* approximate output is: 
* 8.6458 fps and 13372 Hz (but audio is best calculated
* as (frames * 1544) = samples / duration = rate)
*
**************

*
** Cartridge page - >6000 for joystick and >6002 for keyboard
** this is used by all code that needs to return to the code page
CARTPAGE EQU >6000

	COPY "D:\work\ti\dragonslair\code\CommonCode.a99"

    DEF MAIN

    AORG >6000
    
* Now that we don't have a cart header anymore, I've got 28 bytes that I can
* use for a common trampoline function (to avoid needing to copy to scratchpad)
* This will need to be copied into all code banks, but maybe a tool to copy it
* into all banks period would be safest (then even video can return to it)
* TRAMPRET is always at >6000, and returns to R1 on the page in R3, corrupting R0
* You can use B or BL, R11 will be preserved through to the target.
* can only jump to pages with a zero data write
**** MUST NOT MOVE, must be in every page! ****
TRAMPRET
	CLR *R3				* because we bank here, this code MUST always be the same!!
	B *R1
* Only 4 bytes...
	
	AORG >601C

* MAIN must be at >601C - if you change it, change the GPL too
MAIN
	JMP MAINSTART
	
***
* Handle a single video clip until it returns (does F18A test)
* This needs to be at a known address on all pages, so it's placed early
** R6 - JOYMASK
** R7 - number of frames in clip
** R8 - page to start at
** You must set VIDEORET with the page of your return code
** You must call this on the VIDEOPAGE bank
** The scratchpad code will handle the return
**** MUST NOT MOVE, video pages only ****
VIDEO
* save return address
	MOV R11,@SAVE
	
* Update offset
	AI R8,VIDEOFFSET

* check for F18A or not
	MOVB @f18aflg,r0
	jeq nof18vid
	
	bl @VIDYESF18
	jmp donevid
	
nof18vid
	bl @VIDNOF18
    
donevid
 	MOV @SAVE,R1		* return address
 	MOV @VIDEORET,R3	* return page
	B @TRAMPRET			* trampoline
	
* clean up scratchpad so we can safely reboot
* this is not allowed to move either - called from
* the scene pages during practice mode
**** MUST NOT MOVE, video pages only ****
REBOOT
* reset F18A
	BL @RESTF18
	BL @LOCKF18
* wipe scratchpad	
	LI R0,>8304
	LI R1,252
RBLP1
	CLR *R0+
	DECT R1
	JNE RBLP1
* soft reset of console	
	BLWP @>0000
	
* another fixed function - video resume
**** MUST NOT MOVE, video pages only ****
VIDEORESUME
* save return address
	MOV R11,@SAVE
	
* scratchpad code is already loaded, supposedly!	
	bl @>8320

* back to caller    
 	MOV @SAVE,R1		* return address
 	MOV @VIDEORET,R3	* return page
	B @TRAMPRET			* trampoline
    
* MAIN SCREEN TURN ON
MAINSTART
    LIMI 0
    LWPI >8300

* grab the TI random number before we start
    MOV @>83C0,@RNDSED
    JNE RNDAOK
    SETO @RNDSED	* can't be zero
RNDAOK

* save our cartpage as the videopage (only place this is initted)    
	LI R0,CARTPAGE
	MOV R0,@VIDEOPAGE
    
*   * set up sound chip
**************
* The 'beep' played when a correct move is implemented is a fading
* tone that's a mix of D3 (587Hz) and A4 (1760Hz). Since we're only
* doing one channel, D3 is the stronger of the two, so that's what
* we'll use.
**************
    LI R0,>9FBF     * mute all channels
    MOVB R0,@SOUND
    SWPB R0
    MOVB R0,@SOUND
    LI R0,>DFFF
    MOVB R0,@SOUND
    SWPB R0
    MOVB R0,@SOUND
    LI R0,>8100     * highest frequency
    MOVB R0,@SOUND
    SWPB R0
    MOVB R0,@SOUND
    LI R0,>CE0B		* beep frequency on ch 3 (no buzz?)
    MOVB R0,@SOUND
    SWPB R0
    MOVB R0,@SOUND
	LI R0,>DFD6		* beep volumes (mute, loud)
	MOV R0,@BEEPVOL
    
* setup some persistent variables
	clr @cfghints		* also clears f18aflg, but we check that below
	clr @lives			* also clears scr1
	clr @scr2			* also clears scr3
	movb @BYTEFF,@cfgarcade	 * start in arcade mode
	movb @BYTE01,@cfgeasy	 * also want to start with easy mode
    
* test for F18A, and unlock. 
* run 9918A version if it's not there.

* if user is holding shift, then skip F18A test and run without
	LI R12,>0024
	CLR R1
	LDCR R1,3
	NOP
	LI R12,>0010
	TB 0			* is shift pressed?
	JNE F18NO		* if so, skip the GPU test

* We just check if the GPU is present by having it 
* run a short program
* F18A blind unlock code
    LI R0,>B91C             * VR1/57, value 00011100
    BL @VDPWTA              * write once (corrupts VDPR1)
    BL @VDPWTA              * write again (unlocks enhanced mode)

* If we are not on the F18A, then R1 is screwed up now, that's okay
    LI R0,>5C00
    BL @VDPWTA
    LI R1,GPUTEST
    LI R2,10
TSTLP
    MOVB *R1+,@VDPWD        * copy program
    DEC R2
    JNE TSTLP
    
    LI R0,>5C10             * test address
    BL @VDPWTA
    CLR @VDPWD              * clear it
    CLR @VDPWD
    
* Start the GPU program, pause, then check the result
    LI R0,>B61C             * MSB
    BL @VDPWTA
    LI R0,>B700             * LSB and start
    BL @VDPWTA
    NOP                     * give it a moment - it's WAY faster than we are
    LI R0,>1C10
    BL @VDPWTA
    NOP
    MOVB @VDPRD,R1          * read the data
    SWPB R1
    MOVB @VDPRD,R1
    CI R1,>3412
    JNE F18NO
    B @F18YES

F18NO   
	movb @byte00,@f18aflg
*   * set up bitmap
    BL @BITMAP
    B @GAMESTART

** Video playback here. Pass in:
** R6 - JOYMASK
** R7 - number of frames in clip
** R8 - page to start at
**
VIDNOF18
* save return
	MOV R11,@SAVE2
	
* Now copy from OUTLOOP to FINAL into scratchpad
* at >8320 - we'll run from there so that paging
* doesn't bite us (although there is room in each
* video page for this code...)
    LI R0,>8320
    LI R1,OUTLOOP
CPLP1
    MOV *R1+,*R0+
    CI R1,FINAL
    JL CPLP1
    
* set up copy

* We /could/ get away with 3 blocks, and I did that originally.
* The idea of using four is to interleave the painting more so
* pattern updates are more closely followed by color udpates.
* it causes more obvious paints, but this looks better than the flicker.
*
* With the discovery that LI is faster than MOV in scratchpad,
* I've freed up all the fixed value registers that were used only to init
*

* Convert R8 (page number) into R8/R9 (address/data)
	MOV r8,r9
	SRL R9,4
	ANDI R9,>0F00
	ANDI R8,>0FFF
	SLA R8,1
	AI R8,>6000

*	R0 is reserved for scratch
*	R1 is reserved for scratch
*	R2 is used for joystick calculations
*   R3 is used (on F18A side only) to hold the VDP address
    CLR R4			* R4 is reserved for JOYDAT
*   CLR R5			* R5 is reserved for JOYOLD
*   LI R6,>0700		* R6 is reserved for JOYMASK (left,right,fire)
*	MOV @FRAMES,r7
*   li r8,>6002     * address for paging
*   clr r9          * data for paging
    li r10,>6020	* address we are reading from
*   R11 reserved for BL
	LI R12,>0006    * fixed for CRU access to keyboard and joystick (columns at 15,16,17)
    LI r13,VDPWD
    li r14,VDPWA
    li r15,SOUND
    SBZ 15			* first bit of keyboard select is always 0, only need to change 16&17
    
*
* try to keep the cycles between sound writes about even
* the setup blocks need to be 2 cycles longer than the copy blocks
* to make up for the JNE fallthrough being 2 cycles shorter.
*
* Although the smaller code needs fewer bytes to VDP, to keep the
* code reasonably tight, we now need EIGHT copy loops.
* 
* The data pattern needs to be (P=PATTERN, C=COLOR, S=Sound):
* 1     S
* 192   PPPPS   first 1/3rd, chars 0-95
* 1     S
* 192   CCCCS
* 1     S
* 192   PPPPS   second 1/3rd, chars 0-95
* 1     S
* 192   CCCCS
* 1     S
* 192   PPPPS   second 1/3rd, chars 96-191
* 1     S
* 192   CCCCS
* 1     S
* 192   PPPPS   third 1/3rd, chars 0-95
* 1     S
* 192   CCCCS
*
* Repeat - above sequence is first pattern data, then color data (color at >2000)
* We are interleaving the pattern and color through each table. However, one frame per page
* starting at >6020
*
*                                                  8Bit 16bit 

* So go to 'er!
    B @>8320
    
* absolute return point, so we don't need to save R11
* When we get here, JOYDAT has the newly detected joystick data
* JOYOLD has the joystick data ('1' is active)
* if R7 is >FFFF, then the video has played out
* (After we increment, it's if R7 is zero)
ABSRET
	INC R7
	JEQ NOBEEP
	MOVB @BEEPVOL+1,@SOUND			* make the accepted joystick beep
NOBEEP
	MOV @SAVE2,R11
	B *R11

**********************************
* Code for quit, joystick, and frame countdown are interleaved with the
* frames, with the intent of keeping the audio properly spaced.
* Despite my best attempts to cycle count, in the end I just
* removed the delays and pushed it as best I could.
* original goal was 220 cycles between samples, final result was
* to get as close as possible to what the main loop achieves, which
* is about 218 cycles. Luckily there are 192 loops of tight copies,
* and then the blocks below which are a bit off. This means I made
* the delay blocks as close as possible to 48 cycles, but the reality
* is that 40 cycles is actually closer to correct.
**********************************

* follow code is copied to >8320 and run from scratchpad
* can enable this AORG to get the scratchpad address of LOOP1X
* AORG >8320
OUTLOOP

* increment page, and prepare the address to copy from (10 jmp to here)
    MOV r9,*R8+                                     30
    LI R10,>6020                                    12  - 50 cycles (10 cycles over)

* Pattern 1 
    LI R0,>0040     * start address table 1 >0000   12
    BL @LOOP1                                       20 (accounted for in LOOP)

* check page increment
    CI R8,>8000                                     14  - check for end of cart space
    JNE NOTLP                                       10  - continue if not there yet
    LI R8,>6002                                     ...12 - else reset and
    AI R9,>0100                                     ...10 - increment data
NOTLP   
	SBZ 16											12
	SBZ 17											12 - set QUIT column - 48 cycles (8 cycles over)

* Color 1
    LI R0,>0060     * start address table 3 >2000   12
    BL @LOOP1                                       20 (accounted for in LOOP)
    
* check for end of video
	DEC R7											10
	JOC NOTYET										10
	CLR @CARTPAGE                                   ...26 (reset cartridge bank for code jump)
	B @ABSRET										...16-2 for branch, but we are looping
NOTYET
* read the FCTN and EQUALS keys
	TB 0											12 (equals)
	JEQ KEYOK										10
	TB 4											...12 (fctn)
	JEQ KEYOK										...10
	CLR @CARTPAGE                                   ......26 (reset cartridge bank for code jump)
	B @REBOOT										......16-2 (but who cares, we're rebooting)
KEYOK
*	         										  - 42 cycles (2 cycles over)
*                                                      (22 over if equals down, count not calculated on repeat)

* Pattern 2
    LI R0,>0048     * start address table 2 >0800   12
    BL @LOOP1                                       20 (accounted for in LOOP)
    
* prepare joystick read
	SBO 16                                          12
	SBO 17                                          12 - select column 6
* delay
    SRL R0,2                                        16 - 40 cycles

* Color 2
    LI R0,>0068     * start address table 4 >2800   12
    BL @LOOP1                                       20 (accounted for in LOOP)

* read the joystick lines
	STCR JOYDAT,8								    44 - 44 cycles (4 over)

* Pattern 2b
    LI R0,>004B     * start address table 5 >0B00   12
    BL @LOOP1                                       20 (accounted for in LOOP)

* check joystick results
	mov JOYDAT,r2	                                14 - make a copy to work on
	mov JOYDAT,r2	                               	14 - waste time
	inv JOYDAT		                                10 - invert the bits - 38 cycles (2 short)

* Color 2b
    LI R0,>006B     * start address table 7 >2B00   12
    BL @LOOP1                                       20 (accounted for in LOOP)

* continue processing joystick data
	xor JOYOLD,JOYDAT                               14 - xor with old to get changed
	szc r2,JOYDAT	                                14 - and to get only newly active bits (ignore released)
	inv r2			                                10 - prepare to save off new 'old' - 38 cycles (2 short)

* Pattern 3
    LI R0,>0050     * start address table 6 >1000   12
    BL @LOOP1                                       20 (accounted for in LOOP)

* finish processing the joystick, including early exit check
	mov r2,JOYOLD	                                14
	czc JOYMASK,JOYDAT                              14
	jeq JOYOK		                                10 - normal case, we do not exit!
	CLR @CARTPAGE                                   ...26 (reset cartridge bank for code jump)
	B @ABSRET                                       ...16 (joystick told us to exit)
JOYOK
*                                                      - 38 cycles (2 short)

* Color 3
    LI R0,>0070     * start address table 8 >3000   12
    BL @LOOP1										20 (accounted for in LOOP)

* back to the top!
	MOVB @BEEPVOL,*R15	* beep tone					54 - puts us 54 cycles over budget, but longer beep!
    JMP OUTLOOP                                     10
    
* this is the actual copy block - VDP address in R0, which is destroyed
LOOP1X
*                                                   42 (init & BL & RT + 48 cycles wasted in callers)
    MOVB R0,*R14                                    26
	MOVB @>8301,*R14								34 (R0 LSB - sets VDP write address)
    LI R0,192                                       12 (blocks to write)
    MOVB *R10+,*R15     * write sound               62  -   224 (6 over, when 48 cycles are used)

* This loop executes 192 times, then ONE of the other paths happens, so the slight
* miscounts are not too easily noticed.
LOOP1Y
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R15   * write sound                 62  -   218 (including dec and jne)
    DEC R0                                          10
    JNE LOOP1Y                                      10
    
    B *R11                                          12 (-2 for JNE fallthrough)
FINAL

*************** 
*************** F18A Version
*************** 

F18YES  
	movb @byte01,@f18aflg
* good, copy the GPU program in and start it
    LI R0,>7800
    BL @VDPWTA
    LI R1,GPUGO
GLDLP
    MOVB *R1+,@VDPWD
    CI R1,GPUEND
    JNE GLDLP
    
* start running (it will move itself into high memory)
    LI R0,>B638             * MSB
    BL @VDPWTA
    LI R0,>B700             * LSB and start
    BL @VDPWTA
    
*   * set up bitmap
    BL @BITMAP
    B @GAMESTART

** Video playback here. Pass in:
** R6 - JOYMASK
** R7 - number of frames in clip
** R8 - page to start at
**
VIDYESF18
* Save the return address
	MOV R11,@SAVE2

* Now copy from OUTLOOP18 to FINAL18 into scratchpad
* at >8320 - we'll run from there so that paging
* doesn't bite us (although there is room in each
* video page for this code...)
    LI R0,>8320
    LI R1,OUTLOOP18
CPLP118
    MOV *R1+,*R0+
    CI R1,FINAL18
    JL CPLP118
    
* Theory of op:
* This uses 4 copies like the original code, and has the same
* timing and tearing limitations. The difference is that
* each block is copied to 'unused' video RAM, and a command
* written to the polling GPU program.
* The GPU then copies the block as instructed.
* First, the CPU writes the pattern table, then toggles the
* GPU. The GPU copies the pattern data to a block in high
* memory (mostly because we're out of memory in the main
* VDP space, and we can afford the time).
* The CPU then (possibly starting overlapped) copies the
* color table to the buffer. The command next written
* instructs the GPU to copy both pattern and color to the
* correct place for display. Because the GPU has random access
* to VDP memory, it can alternate writes for minimum time
* between updates. Because it's so blinding fast, it should
* easily finish the update before the next block is ready.
* the result should be nearly flicker-free video.
*

* Convert R8 (page number) into R8/R9 (address/data)
	MOV r8,r9
	SRL R9,4
	ANDI R9,>0F00
	ANDI R8,>0FFF
	SLA R8,1
	AI R8,>6000

* So, the 9900 always writes starting at >3800,
* it then writes one extra byte to >3B00, containg a GPU
* command:
* 0x80  -   copy to second buffer
* 0x20  -   copy first blocks
* 0x28  -   copy second blocks
* 0x2B  -   copy third blocks
* 0x30  -   copy fourth blocks

*	R0 is reserved for scratch
*	R1 is reserved for scratch
*	R2 is used for joystick calculations
*   R3 is used (on F18A side only) to hold the VDP address
	LI R3,>0078		* address of VDP buffer (>3800)
    CLR R4			* R4 is reserved for JOYDAT
*   CLR R5			* R5 is reserved for JOYOLD
*   LI R6,>0700		* R6 is reserved for JOYMASK (left,right,fire)
*	MOV @FRAMES,r7
*   li r8,>6002     * address for paging
*   clr r9          * data for paging
    li r10,>6020	* address we are reading from
*   R11 reserved for BL
	LI R12,>0006    * fixed for CRU access to keyboard and joystick (columns at 15,16,17)
    LI r13,VDPWD
    li r14,VDPWA
    li r15,SOUND
    SBZ 15			* first bit of keyboard select is always 0, only need to change 16&17
    
* So go to 'er!
    B @>8320
	
**********************************
* following code is copied to >8320 and run from scratchpad
* it's unfortunate we need an F18A version, but the minor
* changes are worth it, to keep performance up.
**********************************
* can enable this AORG to get the scratchpad address of LOOP18X
* AORG >8320

OUTLOOP18
* increment page, and prepare the address to copy from (10 jmp to here)
    MOV r9,*R8+                                     30
    LI R10,>6020                                    12  - 52 cycles (12 cycles over)

* Pattern 1
    LI R0,>8000     * command address table         12
    BL @LOOP18                                      20

* check page increment
    CI R8,>8000                                     14  - check for end of cart space
    JNE NOTLP18                                     10  - continue if not there yet
    LI R8,>6002                                     ...12 - else reset and
    AI R9,>0100                                     ...10 - increment data
NOTLP18   
	SBZ 16											12
	SBZ 17											12 - set QUIT column - 48 cycles (8 cycles over)

* Color 1
    LI R0,>2000     * command copy first blocks     12
    BL @LOOP18                                      20

* check for end of video
	DEC R7											10
	JOC NOTYET18   									10
	CLR @CARTPAGE                                   ...26 (reset cartridge bank for code jump)
	B @ABSRET										...16-2 for branch, but we are looping (shared return)
NOTYET18
* read the FCTN and EQUALS keys
	TB 0											12 (equals)
	JEQ KEYOK18										10
	TB 4											...12 (fctn)
	JEQ KEYOK18										...10
	CLR @CARTPAGE                                   ......26 (reset cartridge bank for code jump)
	B @REBOOT										......16-2 (but who cares, we're rebooting)
KEYOK18
*	         										  - 42 cycles (2 cycles over)
*                                                      (22 over if equals down, count not calculated on repeat)

* Pattern 2
    LI R0,>8000     * command address table         12
    BL @LOOP18                                      20

* prepare joystick read
	SBO 16                                          12
	SBO 17                                          12 - select column 6
* delay
    SRL R0,2                                        16 - 40 cycles
    
* Color 2
    LI R0,>2800     * command copy second blocks    12
    BL @LOOP18                                      20

* read the joystick lines
	STCR JOYDAT,8								    44 - 44 cycles (4 over)

* Pattern 2b
    LI R0,>8000     * command address table         12
    BL @LOOP18                                      20

* check joystick results
	mov JOYDAT,r2	                                14 - make a copy to work on
	mov JOYDAT,r2	                               	14 - waste time
	inv JOYDAT		                                10 - invert the bits - 38 cycles (2 short)

* Color 2b
    LI R0,>2B00     * command copy third blocks     12
    BL @LOOP18                                      20
    
* continue processing joystick data
	xor JOYOLD,JOYDAT                               14 - xor with old to get changed
	szc r2,JOYDAT	                                14 - and to get only newly active bits (ignore released)
	inv r2			                                10 - prepare to save off new 'old' - 38 cycles (2 short)

* Pattern 3
    LI R0,>8000     * command address table         12
    BL @LOOP18                                      20

* finish processing the joystick, including early exit check
	mov r2,JOYOLD	                                14
	czc JOYMASK,JOYDAT                              14
	jeq JOYOK18		                                10 - normal case, we do not exit!
	CLR @CARTPAGE                                   ...26 (reset cartridge bank for code jump)
	B @ABSRET                                       ...16 (joystick told us to exit)
JOYOK18
*                                                      - 38 cycles (2 short)

* Color 3
    LI R0,>3000     * command copy fourth blocks    12
    BL @LOOP18                                      20

* back to the top!
	MOVB @BEEPVOL,*R15	* beep tone					54 - puts us 54 MORE cycles over budget, but longer beep!
    JMP OUTLOOP18                                   10

* this is the actual copy block 
* pass the command byte in R0, R1 is destroyed (unlike the non-F18A version which takes and destroys R0)
* Warning: this is 2 bytes longer than the non-F18A version!
LOOP18X
*                                                   42 (init & BL & RT + 48 cycles wasted in callers)
    MOVB R3,*R14                                    26
    MOVB @>8307,*R14								34 (R3 LSB)
    LI R1,192                                       12
    MOVB *R10+,*R15     * write sound               62  -   224 (6 over, when 48 cycles are used)

* This loop executes 192 times, then ONE of the other paths happens, so the slight
* miscounts are not too easily noticed.
LOOP18Y
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R13   * data                        34
    MOVB *R10+,*R15   * write sound                 62  -   218 (including dec and jne)
    DEC R1                                          10
    JNE LOOP18Y                                     10
    
    MOVB R0,*R13									26 - command byte - makes us 26 more over
    B *R11

FINAL18

* back refs for the Scratchpad address of the loops
LOOP1   EQU LOOP1X-OUTLOOP+>8320
LOOP18  EQU LOOP18X-OUTLOOP18+>8320

* GPU code (loads at >3800 in VDP, copies itself to >4000)
* to make life easy, position independent code! (VDP
* addresses are hard coded though, that's fine)
GPUGO
    li r0,>3800+GPURUN-GPUGO
    li r1,>4300
GCPLP
    MOV *r0+,*r1+
    ci r0,>3800+GPUEND-GPUGO
    jne GCPLP

* now jump to it!   
    B @>4300
    
* this code running at >4300
GPURUN
    clr @>3B00      * zero command
    CLR R0
GPUWAIT
    MOVB @>3B00,R0  * get it
    JEQ GPUWAIT     * nothing yet
    CLR @>3B00      * clear it
    JLT BUFCPY      * copying to second buffer
    
* main buffer copy - copy >4000 to pattern, and >3800 to color
* R0 contains the color table target address
    MOV R0,R1       * for pattern table
    ANDI R1,>1FFF
    LI R2,>3800     * R2->R0 for the color table
    LI R3,>4000     * R3->R1 for the pattern table
    LI R4,96        * we can move words instead of bytes
GPUVLP  
    MOV *R2+,*R0+
    MOV *R3+,*R1+
    MOV *R2+,*R0+
    MOV *R3+,*R1+
    MOV *R2+,*R0+
    MOV *R3+,*R1+
    MOV *R2+,*R0+
    MOV *R3+,*R1+
    DEC R4
    JNE GPUVLP
    JMP GPURUN      * go wait again

BUFCPY
    LI R0,>3800     * 9900 write buffer
    LI R1,>4000     * second buffer target when >80
    LI R2,96        * we can move words instead of bytes
GPUBLP
    MOV *R0+,*R1+
    MOV *R0+,*R1+
    MOV *R0+,*R1+
    MOV *R0+,*R1+
    DEC R2
    JNE GPUBLP
    JMP GPURUN      * go wait again

GPUEND

* GPU TEST must be 10 bytes... (copied and run on F18A GPU)
GPUTEST
    LI R0,>1234
    MOV R0,@>1C10
    IDLE

* Setup for normal 0 mode
* returns with video off - set VDP R1 to E2 to enable (>81E2)
* at this point we know if we have an F18A or not
BITMAP
    MOV R11,@SAVE

* set display and disable sprites
    LI R1,REG9938		* regs for 9938 compatibility
	MOVB @f18aflg,r0	* do we have an F18A?
	JEQ BMNOF18
	LI R1,BMREGS		* skip the 9938 regs if we do, they will conflict
BMNOF18	
    BL @LOADRG
    
* set up SIT - copy from first graphic frame
    LI R0,>5800
    LI R1,CFGSIT
    LI R2,768
    LI R3,CFGHEA	* frame to copy from
    BL @VMBWP
    
* now it takes a few loops to copy in the
* color and pattern data, they are spaced
* Pattern is packed first (unlike the video stills)
* set up PATTERN - (R1 already set)
* chars 0x60-0xff
    LI R0,>4300
    LI R1,CFGPAT
    LI R2,160*8
    LI R3,CFGBORD
    BL @VMBWP
    
* chars 0x1C0-0x1FF (R1 already set)
	LI R0,>4E00
	LI R2,64*8
    LI R3,CFGBORD
	BL @VMBWP
	
* chars 0x260-0x2FF (R1 already set)
	LI R0,>5300
	LI R2,160*8
    LI R3,CFGBORD
	BL @VMBWP

* set up COLOR (R1 is already set)
* chars 0x60-0xff
    LI R0,>6300
    LI R2,160*8
    LI R3,CFGBORD
    BL @VMBWP
    
* chars 0x1C0-0x1FF (R1 already set)
	LI R0,>6E00
	LI R2,64*8
    LI R3,CFGBORD
	BL @VMBWP
	
* chars 0x260-0x2FF (R1 already set)
	LI R0,>7300
	LI R2,160*8
    LI R3,CFGBORD
	BL @VMBWP
	
* set up sprite tables (will overwrite existing byte)
	LI R0,>5B00		* SAL (blank), all data will follow (see sprites.a99)
	LI R1,>6000
	LI R2,>0330
	LI R3,CFGSPRITES
	BL @VMBWP

* back to caller    
    MOV @SAVE,R11
    B *R11
	
* VMBWP via a page - corrupts scratchpad at >8320	
* R0 - VDP address (with >4000 set)
* R1 - src address (register saved but incremented)
* R2 - count
* R3 - video page to copy from (as in ROM LAYOUT.txt)
VMBWP
	MOV R11,@SAVE2 		* frees R11
	BL @VDPWTA	   		* set VDP address - frees R0
* Add in offset
	AI R3,VIDEOFFSET
* copy the code into scratchpad
	LI R11,VMBWPA  		* R11 is free to reuse
	LI R0,>8320	   		* R0 is free to reuse
VMBCP1	
	MOV *R11+,*R0+
	CI R11,VMBWPE
	JNE VMBCP1
* Get the banking info ready (convert index into page and data)
	MOV r3,r0	   		* r0 is free to reuse
	SRL R0,4
	ANDI R0,>0F00
	ANDI R3,>0FFF
	SLA R3,1
	AI R3,>6000
* Do the actual copy
	BL @>8320
* and back to caller	
	MOV @SAVE2,R11
	B *R11
	
VMBWPA
* Entry here at >8320. R3 has page address, R0 has page data in MSB
	MOV R0,*R3
LPA2
	MOVB *R1+,@>8C00
	DEC R2
	JNE LPA2
	CLR @CARTPAGE
	B *R11
VMBWPE

* registers for bitmap (and 5B00 is the write address of the sprite table)
* background is transparent (the only color never redefined)
* PDT - >0000
* SIT - >1800
* SDT - >1800
* CT  - >2000
* SAL - >1B00
REG9938 DATA >8808,>8900,>8A00,>8B00,>8C00,>8D00,>8E00,>8F00
BMREGS DATA >81E3,>8002,>8206,>83ff,>8403,>8536,>8603,>8700,>5B00,>0000
* REG9938 are the registers for 9938 compatibility - load these from 8-F before 
* loading the 9918's 0-7, and you should be good to go. Only if no F18A. Unlocked
* F18A will have all kinds of fun with these...

* load regs list to VDP address, end on >0000 and write >D0 (for sprites)
* address of table in R1 (destroyed)
LOADRG
LOADLP
    MOV *R1+,R0
    JEQ LDRDN
    SWPB R0
    MOVB R0,@>8C02
    SWPB R0
    MOVB R0,@>8C02
    JMP LOADLP
LDRDN
    LI R1,>D000
    MOVB R1,@>8C00
    B *R11

* Write address or register
VDPWTA
    SWPB R0
    MOVB R0,@>8C02
    SWPB R0
    MOVB R0,@>8C02
    B *R11  
	
**
* RESTF18 - Reset the GPU on the F18 (no harm if not F18, 
* but expect registers to be messed up)	
* We don't use palettes, so removed that code
RESTF18
	MOVB @f18aflg,R0		* do nothing if no F18A
	JNE RESTG18
	B *R11

RESTG18	
	MOV R11,@SAVE2
	
* stop the GPU and then Reset (no harm if it's not F18)
	LI R0,>B800				* stop the GPU -- this does stop the GPU
	BL @VDPWTA				* GPU will stop long before we're done

	MOV @SAVE2,R11
	B *R11
	
* lock F18 if it's still unlocked (pre 1.6)
LOCKF18
	MOV R11,@SAVE2

* reset the F18A to defaults (except palette, requires 1.6)	
	LI R0,>B280				* VR2/50, value 10000000
	BL @VDPWTA				* reset and lock F18A, or corrupt R2
	
	LI R0,>B900       		* VR1/57, value 00000000
	BL @VDPWTA          	* write once (corrupts VDPR1)
	
	MOV @SAVE2,R11
	B *R11	
	
**********************
* More subroutines! so unorganized!
**********************
* Corrupts R12,R13 - only checks for S,D,H or 5
* S	row 1, address >10 - return 1
* D	row 2, address >10 - return 2
* H	row 4, address >08 - return 4
* 5 row 4, address >0E - return 8
KSCAN
		LI R13,>0100
		LI R12,>0024		* column select
		LDCR R13,3
		SRC R12,7			* Delay?
		LI R12,>0010		* row select
		TB 0
		JEQ KEYNS
		LI R13,>0100
		B *R11
KEYNS
		LI R13,>0200
		LI R12,>0024		* column select
		LDCR R13,3
		SRC R12,7			* Delay?
		LI R12,>0010		* row select
		TB 0
		JEQ KEYND
		LI R13,>0200
		B *R11
KEYND
		LI R13,>0400
		LI R12,>0024		* column select
		LDCR R13,3
		SRC R12,7			* Delay?
		LI R12,>0008		* row select
		TB 0
		JEQ KEYNH
		LI R13,>0400
		B *R11
KEYNH
		TB 3
		JEQ KEYN5
		LI R13,>0800
		B *R11
KEYN5
		CLR R13
		B *R11

* VSMW - VDP Single Byte Multiple Write
* VDP - R0 (with >4000 set)
* Byte- R1 MSB
* Cnt - R2
VSMW
	MOV R11,@SAVE2
	BL @VDPWTA	   		* set VDP address - frees R0
VSMW1
	MOVB R1,@VDPWD
	DEC R2
	JNE VSMW1
	MOV @SAVE2,R11
	B *R11

* Fast joystick read with fire - kills R12 and R10, uses JOYDAT
* blocking, too, there's a NOP
* also checks for QUIT
JOYFAST
* check QUIT (same code as console ROM)
	LI 12,>0024 		* Load CRU
	LDCR @>0012,3
	SRC 12,7			* delay
	LI 12,>0006
	STCR R10,8 			* Fetch CRU
	CZC @QUITK,R10 		* QUIT key?
	JNE MENUKY
	B @REBOOT			* reboot if yes
MENUKY
* read joystick
	li r12,>0024
	li r10,>0600
	ldcr r10,3
	NOP
	li r12,>0006
	stcr JOYDAT,8
	INV JOYDAT			* make sure '1' bits are active
	B *R11
	
* set the color table for video to black
BLACKVID
	MOV R11,@SAVE3
	
	LI R0,>6000
	CLR R1
	LI R2,768
	BL @VSMW
	
	LI R0,>6800
	LI R2,1536
	BL @VSMW
	
	LI R0,>7000
	LI R2,768
	BL @VSMW
	
	MOV @SAVE3,R11
	B *R11

* same as SHOWANDPAUSE below without the blackvid call, for the options screen
SHOWANDPAUSE2
	MOV R11,@SAVE
	MOV R0,R9		* src page
	MOV R1,R13
	JMP SAPCONT
	
* shows a frame from R0 and waits for R1 frames
* also kills R9,R10,R12,R13,JOYDAT....
* must be possible to abort with fire button (but not HOLDING fire)
SHOWANDPAUSE
	MOV R11,@SAVE
	MOV R0,R9		* src page
	MOV R1,R13
	
* first black the color table to avoid corruption
	BL @BLACKVID

SAPCONT	
* now load the new image
	LI R0,>4000		* pattern
	LI R1,CFGPAT
	LI R2,768
	MOV R9,R3
	BL @VMBWP
	
	LI R0,>4800
	LI R2,1536
	MOV R9,R3
	BL @VMBWP
	
	LI R0,>5000
	LI R2,768
	MOV R9,R3
	BL @VMBWP
	
	LI R0,>6000		* color
	LI R2,768
	MOV R9,R3
	BL @VMBWP
	
	LI R0,>6800
	LI R2,1536
	MOV R9,R3
	BL @VMBWP
	
	LI R0,>7000
	LI R2,768
	MOV R9,R3
	BL @VMBWP

	MOV @SAVE,R11
* fall into delay	
	
* delay for R13 frames, allow exit on fire	
DELAY	
	MOV R11,@SAVE
	BL @JOYFAST
	ANDI JOYDAT,JOYFIRE		* FIRE key (save current status)
	MOV JOYDAT,JOYOLD
	MOVB @VDPST,R11			* clear VDP status

DELLP
	BL @JOYFAST
	ANDI JOYDAT,JOYFIRE		* only fire
	C JOYDAT,JOYOLD			* check for change
	JEQ DELSKIP				* no change
	MOV JOYDAT,JOYOLD		* backup, and test for zero
	JNE DELDONE				* if it's pressed

DELSKIP	
	CLR R12					* set CRU base (doesn't need to be in loop, but provides delay)
	TB 2 					* check VDP interrupt input
	JEQ DELLP				* if not set, keep waiting
	MOVB @VDPST,R11	  		* reset status
	DEC R13
	JNE DELLP

DELDONE	
	MOV @SAVE,R11
	B *R11
	
showscore
* show score (kind of BCD-ish, each byte is 0-99)
* digits in segment 3 are characters 167 (A7) on top and add 32 for bottom
* space is 177 (B1)
* score starts at >1AA7
* lives is at >1AB7
	LI R0,>A75A
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	CLR R1			* have to just once
	
	MOVB @scr1,@>8303	* R1 LSB
	SLA R1,1		* multiply by 2
	MOV @BCDLOOKUP(R1),R0
	MOVB R0,@VDPWD
	SWPB R0
	MOVB R0,@VDPWD
	
	MOVB @scr2,@>8303	* R1 LSB
	SLA R1,1		* multiply by 2
	MOV @BCDLOOKUP(R1),R0
	MOVB R0,@VDPWD
	SWPB R0
	MOVB R0,@VDPWD
	
	MOVB @scr3,@>8303	* R1 LSB
	SLA R1,1		* multiply by 2
	MOV @BCDLOOKUP(R1),R0
	MOVB R0,@VDPWD
	SWPB R0
	MOVB R0,@VDPWD
	
	LI R0,>C75A			* second row
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	
	MOVB @scr1,@>8303	* R1 LSB
	SLA R1,1		* multiply by 2
	MOV @BCDLOOKUP(R1),R0
	AI R0,>2020
	MOVB R0,@VDPWD
	SWPB R0
	MOVB R0,@VDPWD
	
	MOVB @scr2,@>8303	* R1 LSB
	SLA R1,1		* multiply by 2
	MOV @BCDLOOKUP(R1),R0
	AI R0,>2020
	MOVB R0,@VDPWD
	SWPB R0
	MOVB R0,@VDPWD
	
	MOVB @scr3,@>8303	* R1 LSB
	SLA R1,1		* multiply by 2
	MOV @BCDLOOKUP(R1),R0
	AI R0,>2020
	MOVB R0,@VDPWD
	SWPB R0
	MOVB R0,@VDPWD

	B *R11
	
showlives
* show lives (0-5)
	LI R0,>B75A
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	
	MOVB @lives,R1
	AI R1,>A700
	MOVB R1,@VDPWD
	
	LI R0,>D75A
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	
	AI R1,>2000
	MOVB R1,@VDPWD

	B *R11
	
* Since video playback is getting expensive to call, we'll just put a
* wrapper function here.
* Set JOYMASK, R7 (count), R8 (first frame), and we'll
* set up the trampoline. Call with BL.
CALLVIDEO
	CLR @JOYDAT			* we reuse it sometimes...
	LI R0,CARTPAGE		* my page
	MOV R0,@VIDEORET	* how to get back to me
	LI R1,VIDEO			* needs to be an equate in other pages...
	MOV @VIDEOPAGE,R3	* page of the video player
	B @TRAMPRET

* RND RETURN RANDOM NUMBER IN R0 
RMASK	DATA >B400				* mask for 16 bit random numbers
RND		MOV  @RNDSED,R0         * Get seed
		SRL  R0,1				* shift down
		JNC  RAND01				* jump if 1 not shifted out
		XOR  @RMASK,R0			* XOR the top half
RAND01	MOV  R0,@RNDSED         * Save this number for next time 
		B    *R11 
		
* write 16-bit R1 to VDP R0 (must have write bit set) 
VDPW16		
    SWPB R0
    MOVB R0,@VDPWA
    SWPB R0
    MOVB R0,@VDPWA
    NOP
    MOVB R1,@VDPWD
    MOVB @>8303,@VDPWD		* LSB
    B *R11
    
* read 16-bit R1 from VDP R0 (must NOT have write bit set)    
VDPR16
    SWPB R0
    MOVB R0,@VDPWA
    SWPB R0
    MOVB R0,@VDPWA
    NOP
	MOVB @VDPRD,R1
	MOVB @VDPRD,@>8303		* LSB
	B *R11

*********************************************************
* Actual game code starting up here (post-init)
*********************************************************
GAMESTART

* run a simple attract mode
	
* if F18A is detected, then show that splash screen first
	MOVB @f18aflg,R0
	jeq nof18splash
	LI R0,CFGF18
	LI R1,120
	BL @SHOWANDPAUSE
nof18splash

* JOYSTICK ONLY - if Alpha lock is DOWN, then wait for release
	clr r12
	sbz >0015
	nop
	tb 7
	jeq AlphaUp
* Load warning screen
	LI R0,>2a5c
	LI R1,1			* don't delay
	BL @SHOWANDPAUSE
* wait for up or quit
AlphaDown
	SBO >0015
	BL @JOYFAST		* don't care what it reads, just using for QUIT
	CLR R12			* restore R12
	sbz >0015
	nop
	TB 7
	JNE AlphaDown
AlphaUp
	SBO >0015
** End alpha lock up for joystick routine

* harmlesslion presents
	LI R0,>2a4a
	LI R1,180
	BL @SHOWANDPAUSE
	MOV JOYDAT,JOYDAT
	JNE OPTIONS
	
ATTRACT

* start video playback of the attract mode
* (which is hardcoded and loops atm...)
	LI JOYMASK,JOYFIRE
	LI R7,>0175			* attract mode frames
	LI R8,>0000			* attract mode starts at
	BL @CALLVIDEO

	ANDI JOYDAT,JOYFIRE
	MOV JOYDAT,JOYDAT
	JNE OPTIONS
	
* instructions 1 (joystick)
	LI R0,>2a4c
	LI R1,600
	BL @SHOWANDPAUSE
	MOV JOYDAT,JOYDAT
	JNE OPTIONS

* instructions 2 (joystick)
* need to display sprites first
	li r0,>853c
	bl @VDPWTA
* now the screen
	LI R0,>2a4e
	LI R1,600
	BL @SHOWANDPAUSE
* now turn off the sprites	
	li r0,>8536
	bl @VDPWTA
* now check joydat...	
	MOV JOYDAT,JOYDAT
	JNE OPTIONS
	
* the license screen
	LI R0,>2a49
	LI R1,480
	BL @SHOWANDPAUSE
	MOV JOYDAT,JOYDAT
	JNE OPTIONS

* the thanks screen
	LI R0,>2a60
	LI R1,480
	BL @SHOWANDPAUSE
	MOV JOYDAT,JOYDAT
	JNE OPTIONS

* else loop back around
	JMP ATTRACT
	
* start the options screen up	
OPTIONS
	BL @BLACKVID
	MOVB @BEEPVOL,@SOUND	* mute beep
	CLR R1
	
OPTDRAW	
	LI R0,CFGHEA		* base config page
	MOVB @cfgarcade,R1
	JNE OPT1
	AI R0,1				* ENHANCED adds 1 frame to base
OPT1
	MOVB @cfghints,R1
	JNE OPT2
	AI R0,4				* HINTS add 4 frames to base
OPT2
	MOVB @cfgeasy,R1	* do this last so we can check practice, too
	JNE OPT3
	AI R0,2				* HARD adds 2 frames to base
OPT3
* a little fixup cause 'practice' came late and messed things up - cfgeasy is '2'
	CI R1,>0200			* is it practice?
	JNE OPT4			* no
	AI R0,29			* practice jumps ahead 29 frames

OPT4
	LI R1,1				* don't wait
	BL @SHOWANDPAUSE2	* get it up

* now we loop through the options, checking
* keyboard for cfg keys (H,S,D) and joystick fire
* KSCAN uses R12,r13 (return in R13). R14 will be old key.
* JOYFAST uses R12,JOYDAT and JOYOLD
	BL @KSCAN
	MOV R13,R14
	BL @JOYFAST
	ANDI JOYDAT,JOYFIRE
	MOV JOYDAT,JOYOLD

OPTLP
	BL @RND			* scramble random number
	BL @KSCAN
	C R13,R14		* changed?
	JEQ NONEWKEY
	MOV R13,R14		* remember change
	CI R13,>0100	* was it S?
	JNE NOKEYS
* Handle S
	MOVB @cfgarcade,r0
	inv r0
	movb r0,@cfgarcade
	jmp OPTDRAW

NOKEYS
	CI R13,>0200	* was it D?
	JNE NOKEYD
* Handle D
	ab @BYTE01,@cfgeasy
	cb @BYTE03,@cfgeasy
	jne OPTDRAW
	movb @BYTE00,@cfgeasy
	jmp OPTDRAW
	
NOKEYD
	CI R13,>0400	* was it H?
	JNE NOKEYH	    * whatever
* handle H
	MOVB @cfghints,r0
	inv r0
	movb r0,@cfghints
	jmp OPTDRAW

NOKEYH
	CI R13,>0800	* was it 5? (Diagnostics)
	JNE NONEWKEY

	LI R3,>6004		* diagnostics banks
	LI R1,>6000		* target address
	B @TRAMPRET		* we aren't coming back

NONEWKEY
	MOV R13,R13		* any key pressed?
	JNE OPTLP		* yes, wait for release

* no key pressed, so check joystick
	BL @JOYFAST
	ANDI JOYDAT,JOYFIRE
	C JOYDAT,JOYOLD		* changed?
	JEQ OPTLP			* nope
	MOV JOYDAT,JOYOLD	* save new state
	JEQ OPTLP			* nothing pressed
	
* option screen exitted with fire -- start the game
	MOVB @BEEPVOL+1,@SOUND	* beep
	BL @BLACKVID
	
	CLR @lives			* and scr1
	clr @scr2			* and scr3

* set correct number of lives based on difficulty
	li r0,liveasy
	movb @cfgeasy,r0
	jne nlivhard
	li r0,livhard
nlivhard
	swpb r0
	movb r0,@lives
	
	BL @showscore
	BL @showlives
	
	MOVB @BYTE00,@justdied	* clear the flag, we manually play the first one
	MOVB @BEEPVOL,@SOUND	* mute beep
	
* AND START THE GAME... 

* so the first thing we are going to do is play the castle overview as
* a video. Then, if we are on arcade mode, we'll also play the slamming
* doors directly. (If we're on enhanced or home, whatever we call it,
* that will play as part of the drawbridge scene).
* So, that's 1 (maybe 2) fixed clips: castle,doors
	CLR JOYMASK
	
* Dragon's Lair counts lives down from 5 to 1, not 4 to 0, so don't decrement at the start
	bl @showlives
	
* now play the castle intro
	LI R8,>018B			* castle start
	LI R7,53			* castle length
	BL @CALLVIDEO
	
* zero out the VDP queues
	LI R0,VDPQ1+>4000
	CLR R1
	LI R2,128
	BL @VSMW
	
* each mode has separate custom sequence code, so just jump to the right one
	MOVB @cfgarcade,r1
	jne doarcade
	b @STARTHOME
	
* doing the arcade here, so first slam those doors and then start the scene selector
doarcade
	LI R8,>021c			* slamming start (plus 2 frames to avoid sound cross-over)
	LI R7,22			* length
	BL @CALLVIDEO

********************************************************
* There are 12 rows, each with three scenes. In addition, up to 5 scenes can be queued for replay (because 5 lives).
* There are three sequences, each plays one scene from each row (queuing scenes you die on), then a fixed scene.
* (The first two fixed scenes are the long elevators, the last is the Dragon's Lair).
*
* I guess to make it easy, we can just play through four queues, first three represented by FIFOs in VDP. 
*
* This way, the scene random logic can be generated by pre-filling the three main queues, one row at a time. 
*
* Then, we just walk through the queues. Finish the first queue, play 7A (repeats till success). Second queue,
* play 7B (repeats till success). After the third queue, we just walk the fourth queue, and ALL scenes
* in that queue are repeated until successful. After the fourth queue (if there was anything), we play the Lair.
*
* Failed scenes are added to the fourth queue.
*
* So,we need to track which queue we're on, and which row in that queue. I'll just track that with code, we have space.
*
* We know the queues are all zeroed right now, so we just need to populate the first three queues with
* the random sequence that we expect the player to go through. Not terribly efficient the way I did it, but eh. ;)
	LI R4,VDPQ1+>4000	* address to start writing at
	LI R2,ARCADETABLE	* start of the table
	LI R3,12			* do this 12 times
filllp
	bl @setrow			* randomly load this row in queues 1-3
	INCT R4				* next row in the queues
	AI R2,12			* next row in the table (doubled)
	DEC R3				* count down
	jne filllp			* keep going

* we have our queues all set up, so we can start the game!
* just get a scene into R1 and then call ALREADYSCENE.
* If we return, get the next scene.
startarcade
	LI R0,VDPQ4+>4000	* going to clear out the replay queue
	MOV R0,@REPLAYQ

* running the first queue
arcadeq1
	li r0,VDPQ1			* and start with the first queue
	MOV R0,@QUEUEVDP
	
arcadeq1lp
	MOV @QUEUEVDP,R0	* get the pointer into R0
	BL @VDPR16			* get the scene index into R1
	MOV R1,R1			* test the result
	JEQ arcadec1		* cycle 1 complete
	INCT R0				* next scene
	MOV R0,@QUEUEVDP	* save the pointer
	BL @ALREADYSCENE	* play the scene!
	jmp arcadeq1lp		* next scene!
	
* cycle 1 complete, so we always play SceneD1Platform
arcadec1
	MOV @REPLAYQ,@queuesave		* remember the pointer in case we die
arcadec1lp
	MOV @queuesave,@REPLAYQ		* restore the pointer in case we died

	LI R1,SceneD1Platform		* play the scene
	BL @ALREADYSCENE
	
* if we died, we have to loop it	
	c @queuesave,@replayq		* did it change?
	jne arcadec1lp				* if yes, restore and repeat scene
	
* now we just move on to cycle 2, repeat of above code
	li r0,VDPQ2			* run the second queue
	MOV R0,@QUEUEVDP
	
arcadeq2lp
	MOV @QUEUEVDP,R0	* get the pointer into R0
	BL @VDPR16			* get the scene index into R1
	MOV R1,R1			* test the result
	JEQ arcadec2		* cycle 2 complete
	INCT R0				* next scene
	MOV R0,@QUEUEVDP	* save the pointer
	BL @ALREADYSCENE	* play the scene!
	jmp arcadeq2lp		* next scene!
	
* cycle 2 complete, so we always play SceneD1Platform2
arcadec2
	MOV @REPLAYQ,@queuesave		* remember the pointer in case we die
arcadec2lp
	MOV @queuesave,@REPLAYQ		* restore the pointer in case we died

	LI R1,SceneD1Platform2		* play the scene
	BL @ALREADYSCENE
	
* if we died, we have to loop it	
	c @queuesave,@replayq		* did it change?
	jne arcadec2lp				* if yes, restore and repeat scene

* now we just move on to cycle 3, repeat of above code
	li r0,VDPQ3			* run the third queue
	MOV R0,@QUEUEVDP
	
arcadeq3lp
	MOV @QUEUEVDP,R0	* get the pointer into R0
	BL @VDPR16			* get the scene index into R1
	MOV R1,R1			* test the result
	JEQ arcadec3		* cycle 3 complete
	INCT R0				* next scene
	MOV R0,@QUEUEVDP	* save the pointer
	BL @ALREADYSCENE	* play the scene!
	jmp arcadeq3lp		* next scene!
	
* cycle 3 complete, so we now play through queue 4, but with no queuing
* to make it easy, we add the dragon's lair to queue 4 now, and then we
* just need the single loop. Home code also jumps here for the final scene.
arcadelair
arcadec3
	MOV @REPLAYQ,R0				* get the pointer
	LI R1,SceneF1Dragonslair	* and the data
	BL @VDPW16
	inct @REPLAYQ				* make it real

	MOV @REPLAYQ,@queuesave		* remember the pointer in case we die (all scenes replay now)
	LI R0,VDPQ4					* prepare to run queue 4
	MOV R0,@QUEUEVDP
	
arcadeq4lp
	MOV @queuesave,@REPLAYQ		* restore the pointer in case we died
	MOV @REPLAYQ,R0				* need to mask off the write bit
	ANDI R0,>3FFF
	C R0,@QUEUEVDP				* check if we're done
	JEQ arcadec4				* cycle 4 complete (game complete, can't use NULL check here)
	MOV @QUEUEVDP,R0			* get the pointer into R0
	BL @VDPR16					* get the scene index into R1
	MOV R1,R1					* test the result (should never be NULL)
	JEQ arcadec4bug				* finished, but also flag a bug...
	BL @ALREADYSCENE			* play the scene!
	
* if we died, we have to loop it	
	c @queuesave,@replayq		* did it change?
	jne arcadeq4lp				* if yes, restore and repeat scene
	
* if we didn't die, check for more scenes	
	MOV @QUEUEVDP,R1	* get the pointer
	INCT R1				* next scene
	MOV R1,@QUEUEVDP	* save the pointer
	jmp arcadeq4lp
	
arcadec4bug
	DATA >0000			* deliberate bad opcode so I can detect it
	
* game won! we're done!	
arcadec4
* display the win screen. Give it a long timeout, but do timeout.
	LI R0,>2a5f
	LI R1,18000			* about 5 minutes
	BL @SHOWANDPAUSE

* we're done. Back to the attract mode
	B @attract
	
* used in the randomization code below
* 64 entries, 6 possible outcomes
* arcade table is roughly random
filltablearc
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo1,fillo2,fillo3,fillo4,fillo5,fillo6
	data fillo2,fillo3,fillo4,fillo5
	
* home table is specifically weighted 50%/37%/12% (ish)
filltablehome
	data fillo1,fillo2,fillo1,fillo2,fillo1,fillo2		* 16 each of these two
	data fillo1,fillo2,fillo1,fillo2,fillo1,fillo2
	data fillo1,fillo2,fillo1,fillo2,fillo1,fillo2
	data fillo1,fillo2,fillo1,fillo2,fillo1,fillo2
	data fillo1,fillo2,fillo1,fillo2,fillo1,fillo2
	data fillo1,fillo2
	data fillo3,fillo4,fillo3,fillo4,fillo3,fillo4		* 12 each of these two
	data fillo3,fillo4,fillo3,fillo4,fillo3,fillo4
	data fillo3,fillo4,fillo3,fillo4,fillo3,fillo4
	data fillo3,fillo4,fillo3,fillo4,fillo3,fillo4
	data fillo5,fillo6,fillo5,fillo6,fillo5,fillo6		* 4 each of these two
	data fillo5,fillo6		

* each 'row' is three entries long, and this is just the arcade table
* there are 12 rows. Three scenes are not listed here:
* SceneD1Platform, SceneD1Platform2, and SceneF1Dragonslair
* the rows are duplicated to allow for the separate reverse check
* used in home mode, since we have space. But it's never different here.
ARCADETABLE
	data SceneC5Ropes1,SceneC5Ropes2,SceneB4Wall
	data SceneC5Ropes1,SceneC5Ropes2,SceneB4Wall
	data SceneC6Horse1,SceneC6Horse2,SceneB1DrinkMe
	data SceneC6Horse1,SceneC6Horse2,SceneB1DrinkMe
	data SceneC7Crypt1,SceneC7Crypt2,SceneE7River
	data SceneC7Crypt1,SceneC7Crypt2,SceneE7River
	data SceneD1PlatShort,SceneD1PlatShort,SceneA1Vestible			* SceneD1PlatShort duplicated on purpose
	data SceneD1PlatShort,SceneD1PlatShort,SceneA1Vestible			* SceneD1PlatShort duplicated on purpose
	data SceneE6Poolballs,SceneE4Electriccage,SceneE2Blacknight
	data SceneE6Poolballs,SceneE4Electriccage,SceneE2Blacknight
	data SceneC6Wizard1,SceneC6Wizard2,SceneC5LizardKing
	data SceneC6Wizard1,SceneC6Wizard2,SceneC5LizardKing
	data SceneC6Smithy1,SceneC6Smithy2,SceneB2Wind
	data SceneC6Smithy1,SceneC6Smithy2,SceneB2Wind
	data SceneB2Vines,SceneB4Snakes,SceneB3Pot
	data SceneB2Vines,SceneB4Snakes,SceneB3Pot
	data SceneC5Pit,SceneB4Goons,SceneB3Fire
	data SceneC5Pit,SceneB4Goons,SceneB3Fire
	data SceneC7Pond1,SceneC7Pond2,SceneE3Catwalk
	data SceneC7Pond1,SceneC7Pond2,SceneE3Catwalk
	data SceneC7Knight1,SceneC7Knight2,SceneE1Bats
	data SceneC7Knight1,SceneC7Knight2,SceneE1Bats
	data SceneB3Throne,SceneE8VanishingFloor,SceneE5Mudmen
	data SceneB3Throne,SceneE8VanishingFloor,SceneE5Mudmen

*****
* copy the three scenes at r2 (CPU) into the queues at r4 (VDP)
* in a random order
setrow
	mov r11,@save3
	
	bl @rnd				* random value to use for reverses
	mov r0,r7			* hold onto this!
	SLA r7,2			* just to get into the word
	bl @rnd				* random value in R0, just choose an order
	srl r0,3			* lsb is usually not very random ;)
	andi r0,>7E			* there are 64 possibilities (slight bias), and we need to multiply by 2, so just take those bits
	movb @cfgarcade,r1	* is it arcade mode?
	jeq rowhome			* no
	ai r0,filltablearc	* table lookup arcade (even distribution)
	mov *r0,r0			* get the index
	b *r0				* call the handler for the selected order (it will return to caller)
	
rowhome
	ai r0,filltablehome	 * home table (weighted distribution)
	mov *r0,r0			* get the index
	b *r0				* call the handler for the selected order (it will return to caller)
	
* wraps the call to VDPW16 and makes the extra determination for flipped or not
* a bit wasteful to always check this since we only care in one small part of
* home mode, but it makes life easier to always do it anyway, and we have the room
* (I keep saying that, I hope it's still true ;) )	
* we must not corrupt r0,r1,r2,r4, and we own r7
* pass queue address to write in R0, and ADDRESS of data in R1 (we may change it before we fetch)
add2q
	SLA R7,1			* get a random bit
	JNC add2q2			* was zero
	AI R1,6				* next row has the inverted entries
add2q2
	mov *r1,r1			* get the word
	B @VDPW16			* write it (will return to caller)

** each of these subs is a different order of copy ;)
fillo1
	mov r4,r0			* first queue
	mov r2,r1			* first element
	bl @add2q
	
	ai r0,32			* second queue
	mov R2,r1
	inct r1				* second element
	bl @add2q
	
	ai r0,32			* third queue
	mov r2,r1
	ai r1,4				* third element
	bl @add2q
	
	mov @save3,r11
	b *r11
	
fillo2
	mov r4,r0			* first queue
	mov r2,r1			* first element
	bl @add2q
	
	ai r0,32			* second queue
	mov r2,r1
	ai r1,4				* third element
	bl @add2q
	
	ai r0,32			* third queue
	mov R2,r1
	inct r1				* second element
	bl @add2q
	
	mov @save3,r11
	b *r11

fillo3
	mov r4,r0			* first queue
	mov R2,r1
	inct r1				* second element
	bl @add2q
	
	ai r0,32			* second queue
	mov r2,r1			* first element
	bl @add2q
	
	ai r0,32			* third queue
	mov r2,r1
	ai r1,4				* third element
	bl @add2q
	
	mov @save3,r11
	b *r11

fillo4
	mov r4,r0			* first queue
	mov R2,r1
	inct r1				* second element
	bl @add2q
	
	ai r0,32			* second queue
	mov r2,r1
	ai r1,4				* third element
	bl @add2q
	
	ai r0,32			* third queue
	mov r2,r1			* first element
	bl @add2q
	
	mov @save3,r11
	b *r11

fillo5
	mov r4,r0			* first queue
	mov r2,r1
	ai r1,4				* third element
	bl @add2q
	
	ai r0,32			* second queue
	mov R2,r1
	inct r1				* second element
	bl @add2q
	
	ai r0,32			* third queue
	mov r2,r1			* first element
	bl @add2q
	
	mov @save3,r11
	b *r11
	
fillo6
	mov r4,r0			* first queue
	mov r2,r1
	ai r1,4				* third element
	bl @add2q
	
	ai r0,32			* second queue
	mov r2,r1			* first element
	bl @add2q
	
	ai r0,32			* third queue
	mov R2,r1
	inct r1				* second element
	bl @add2q
	
	mov @save3,r11
	b *r11

**************************************************************
* Here we are doing the home/enhanced sequence, which starts with the drawbridge
* The queuing is a bit different, so we can use a different block of code.
* 
* There are four main parts.
* 
* First, the drawbridge and vestible always appears. Dying twice on the Drawbridge advances to the Vestible. 
* Neither are queued for replay. 
* 
* Castle Section 1 randomly generates a list of 9 scenes from 3 blocks of 3, with preferences given.
* 
* After all 9, scenes you died on are replayed. However, if you die again, they are skipped.
* 
* Castle section 2 does the same for 9 different scenes, but there is an additional 50:50 chance to decide 
* whether scenes are reversed (if available). You don't have to play both flips of a reversed scene.
* 
* Again, after all 9, scenes you died on are replayed, but you aren't forced to keep playing if you die again.
* 
* Next, the elevator with 9 drops are played. Depending on which of the three groups you jump off at, you get 
* a different adventure in the next sequence.
* 
* There are three adventures, each a different sequence of 8 more scenes. They are not selected randomly, 
* but by where you jumped off the elevator. (Hopefully we can preserve a register to work that out).
* 
* Finally, another single repeat of any scenes you died on.
* 
* And the Dragon's Lair. This one repeats till you win or die.
* 
STARTHOME
	LI R0,VDPQ4+>4000	* going to clear out the replay queue
	MOV R0,@REPLAYQ		* we're going to do this again too...
	MOV @REPLAYQ,@queuesave		* save the queue for easy death detect

* start with the drawbridge. You get two tries, no queuing...
	LI R1,SceneA1Drawbridge
	BL @ALREADYSCENE
	
* if we didn't die, skip ahead
	C @REPLAYQ,@queuesave
	JEQ homevest
	
* second try on drawbridge
	LI R1,SceneA1Drawbridge
	BL @ALREADYSCENE

* live or die, we slip into the vestible for one try
homevest
	LI R1,SceneA1Vestible
	BL @ALREADYSCENE
	
* live or die, we carry on to castle section 1

* prefill the three queues with castle section 1
* since there's no intermediary scenes, we could have used
* just one queue, but this permitted better code reuse with arcade
	LI R0,VDPQ4+>4000	* going to clear out the replay queue
	MOV R0,@REPLAYQ

	li r0,VDPQ1			* and start with the first queue
	MOV R0,@QUEUEVDP	* setting this early so we can loop

	LI R2,hometable1	* start of the table
	LI R4,VDPQ1+>4000	* address to start writing at
	LI R3,3				* do this 3 times
filllph1
	bl @setrow			* randomly load this row in queues 1-3
	INCT R4				* next row in the queues
	AI R2,12			* next row in the table (doubled)
	DEC R3				* count down
	jne filllph1		* keep going
	
* running the queues, we kind of cheat and loop here for queues 1-3
homeq1lp
	MOV @QUEUEVDP,R0	* get the pointer into R0
	BL @VDPR16			* get the scene index into R1
	MOV R1,R1			* test the result
	JEQ homec1			* cycle complete
	INCT R0				* next scene
	MOV R0,@QUEUEVDP	* save the pointer
	BL @ALREADYSCENE	* play the scene!
	jmp homeq1lp		* next scene!

* check if we're done all three queues, loop if not	
* we make a lot of assumptions here, like that the queue is
* only 3 entries long...
homec1
	mov @queuevdp,r1	* get the pointer
	ci r1,VDPQ3			* did it reach queue 3 yet?
	jh homepart2		* yeah, that was queue 3
	ai r1,26			* 32 bytes minus the 6 we already moved, in theory
	mov r1,@queuevdp	* save it
	jmp homeq1lp		* keep going!

* done three queues, now replay any scenes we died on, but only once
* so for that, we keep the replay pointer static
homepart2
	MOV @REPLAYQ,@queuesave		* remember the pointer in case we die (all scenes replay now)
	LI R0,VDPQ4					* prepare to run queue 4
	MOV R0,@QUEUEVDP
	
homeq4lp
	MOV @queuesave,@REPLAYQ		* restore the pointer in case we died
	MOV @REPLAYQ,R0				* need to mask off the write bit
	ANDI R0,>3FFF
	C R0,@QUEUEVDP				* check if we're done
	JEQ homec4					* cycle 4 complete (can't use NULL check here)
	MOV @QUEUEVDP,R0			* get the pointer into R0
	BL @VDPR16					* get the scene index into R1
	MOV R1,R1					* test the result (should never be NULL)
	JEQ homec4bug				* finished, but also flag a bug...
	BL @ALREADYSCENE			* play the scene!
	
* if we died, we ignore that
* either way, check for more scenes	
	MOV @QUEUEVDP,R1	* get the pointer
	INCT R1				* next scene
	MOV R1,@QUEUEVDP	* save the pointer
	jmp homeq4lp
	
homec4bug
	DATA >0000			* deliberate bad opcode so I can detect it

* now we repeat all of the above, but for section 2...	
homec4
* prefill the three queues with castle section 2. Same size, so no need to zero queues.
* since there's no intermediary scenes, we could have used
* just one queue, but this permitted better code reuse with arcade
	LI R0,VDPQ4+>4000	* going to clear out the replay queue
	MOV R0,@REPLAYQ

	li r0,VDPQ1			* and start with the first queue
	MOV R0,@QUEUEVDP	* setting this early so we can loop

	LI R2,hometable2	* start of the table
	LI R4,VDPQ1+>4000	* address to start writing at
	LI R3,3				* do this 3 times
filllph2
	bl @setrow			* randomly load this row in queues 1-3
	INCT R4				* next row in the queues
	AI R2,12			* next row in the table (doubled)
	DEC R3				* count down
	jne filllph2		* keep going
	
* running the queues, we kind of cheat and loop here for queues 1-3
homeq2lp
	MOV @QUEUEVDP,R0	* get the pointer into R0
	BL @VDPR16			* get the scene index into R1
	MOV R1,R1			* test the result
	JEQ homec2			* cycle complete
	INCT R0				* next scene
	MOV R0,@QUEUEVDP	* save the pointer
	BL @ALREADYSCENE	* play the scene!
	jmp homeq2lp		* next scene!

* check if we're done all three queues, loop if not	
* we make a lot of assumptions here, like that the queue is
* only 3 entries long...
homec2
	mov @queuevdp,r1	* get the pointer
	ci r1,VDPQ3			* did it reach queue 3 yet?
	jh homepart3		* yeah, that was queue 3
	ai r1,26			* 32 bytes minus the 6 we already moved, in theory
	mov r1,@queuevdp	* save it
	jmp homeq2lp		* keep going!

* done three queues, now replay any scenes we died on, but only once
* so for that, we keep the replay pointer static
homepart3
	MOV @REPLAYQ,@queuesave		* remember the pointer in case we die (all scenes replay now)
	LI R0,VDPQ4					* prepare to run queue 4
	MOV R0,@QUEUEVDP
	
homeq4lp2
	MOV @queuesave,@REPLAYQ		* restore the pointer in case we died
	MOV @REPLAYQ,R0				* need to mask off the write bit
	ANDI R0,>3FFF
	C R0,@QUEUEVDP				* check if we're done
	JEQ homec42					* cycle 4 complete (can't use NULL check here)
	MOV @QUEUEVDP,R0			* get the pointer into R0
	BL @VDPR16					* get the scene index into R1
	MOV R1,R1					* test the result (should never be NULL)
	JEQ homec42bug				* finished, but also flag a bug...
	BL @ALREADYSCENE			* play the scene!
	
* if we died, we ignore that
* either way, check for more scenes	
	MOV @QUEUEVDP,R1	* get the pointer
	INCT R1				* next scene
	MOV R1,@QUEUEVDP	* save the pointer
	jmp homeq4lp2
	
homec42bug
	DATA >0000			* deliberate bad opcode so I can detect it

* finished the second castle section... now we finally do the elevator
homec42
	LI R0,VDPQ4+>4000	* going to clear out the replay queue
	MOV R0,@REPLAYQ		* we're going to do this again too...
	MOV @REPLAYQ,@queuesave		* save the queue for easy death detect

* You get two tries, no queuing...
	LI R1,SceneD1Platform
	BL @ALREADYSCENE
	
* if we didn't die, skip ahead
	C @REPLAYQ,@queuesave
	JEQ homeelev
	
* second try on platform
	mov @queuesave,@REPLAYQ
	LI R1,SceneD1Platform
	BL @ALREADYSCENE
	
* if we didn't die, skip ahead
	C @REPLAYQ,@queuesave
	JEQ homeelev

* died again? just select cavern adventure 3 into r0
* and then jump ahead to gotcavern
	li r0,2
	jmp gotcavern

homeelev
* figure out which cavern adventure to run by where the player jumped off the elevator
* the three expected levels are >7000,>7100,>7200, and we want 0,1,2, so we can just
* shift and mask. ;) (And if I did this wrong, well, it'll still get something! muhaha.)
	mov @rowbase,r0
	swpb r0
	andi r0,>03
	
gotcavern
	sla r0,4			* 16 bytes in each table
	ai r0,homecave1		* first table - now we have an address
	mov r0,@queuesave	* save it, going to abuse queuesave here

	LI R0,VDPQ4+>4000	* going to clear out the replay queue
	MOV R0,@REPLAYQ		* we're going to do this again too...
	
* now just run through queue - this queue is in queuesave in ROM...
cavernq
	mov @queuesave,r0	* get the current pointer
	mov *r0+,r1			* fetch the scene into r1
	mov r0,@queuesave	* save the result
	BL @ALREADYSCENE	* go play it! Right now, we don't care if we died...

	mov @queuesave,r0	* going to check if done...
	ai r0,-homecave1	* subtract the offset (might not be aligned in ROM)
	andi r0,>0f			* mask down to 0-15 (16 bytes or 8 entries each)
	jne cavernq			* not done yet, so keep playing
	
* now we need to play the replay queue again, one try each
	MOV @REPLAYQ,@queuesave		* remember the pointer in case we die (scenes never replay)
	LI R0,VDPQ4					* prepare to run queue 4
	MOV R0,@QUEUEVDP
	
homeq4lp3
	MOV @queuesave,@REPLAYQ		* restore the pointer in case we died
	MOV @REPLAYQ,R0				* need to mask off the write bit
	ANDI R0,>3FFF
	C R0,@QUEUEVDP				* check if we're done
	JEQ homec43					* cycle 4 complete (can't use NULL check here)
	MOV @QUEUEVDP,R0			* get the pointer into R0
	BL @VDPR16					* get the scene index into R1
	MOV R1,R1					* test the result (should never be NULL)
	JEQ homec43bug				* finished, but also flag a bug...
	BL @ALREADYSCENE			* play the scene!
	
* if we died, we ignore that
* either way, check for more scenes	
	MOV @QUEUEVDP,R1	* get the pointer
	INCT R1				* next scene
	MOV R1,@QUEUEVDP	* save the pointer
	jmp homeq4lp3
	
homec43bug
	DATA >0000			* deliberate bad opcode so I can detect it

* finished the cavern adventure - all that is left is the lair
* go make the arcade code queue and play it.
homec43
	LI R0,VDPQ4+>4000	* going to clear out the replay queue
	MOV R0,@REPLAYQ		* last time!
	b @arcadelair

* table of entries in castle 1 - there are only three rows
* order matters because of the weighting!
* duplicated for the reverse check, though it doesn't apply here
hometable1
	data SceneB2Wind,SceneB2Vines,SceneB1DrinkMe
	data SceneB2Wind,SceneB2Vines,SceneB1DrinkMe
	data SceneB3Pot,SceneB3Throne,SceneB3Fire
	data SceneB3Pot,SceneB3Throne,SceneB3Fire
	data SceneB4Snakes,SceneB4Wall,SceneB4Goons
	data SceneB4Snakes,SceneB4Wall,SceneB4Goons
	
* table in castle 2 - 3 rows again
* order matters because of the weighting!
* these scenes are all reversible EXCEPT for Pit and Lizard King
* So, the rows are listed twice, once normal and once reversed
* this time it matters! :)
hometable2
	data SceneC5Pit,SceneC5Ropes1,SceneC5Lizardking
	data SceneC5Pit,SceneC5Ropes2,SceneC5Lizardking
	data SceneC6Wizard1,SceneC6Smithy1,SceneC6Horse1
	data SceneC6Wizard2,SceneC6Smithy2,SceneC6Horse2
	data SceneC7Crypt1,SceneC7Pond1,SceneC7Knight1
	data SceneC7Crypt2,SceneC7Pond2,SceneC7Knight2
	
* There are three cavern adventures, depending on when
* you jump off the elevator. These scenes are NOT random,
* so they can be queued up directly. There are 8 scenes each.
* since they aren't random, the data isn't duplicated.
homecave1
	data SceneE8Vanishingfloor,SceneE6Poolballs,SceneE7River,SceneE2Blacknight
	data SceneE1Bats,SceneE3Catwalk,SceneE4Electriccage,SceneE5Mudmen
	
homecave2
	data SceneE4Electriccage,SceneE5Mudmen,SceneE2Blacknight,SceneE1Bats
	data SceneE3Catwalk,SceneE8Vanishingfloor,SceneE6Poolballs,SceneE7River
	
homecave3
	data SceneE1Bats,SceneE3Catwalk,SceneE8Vanishingfloor,SceneE4Electriccage
	data SceneE5Mudmen,SceneE6Poolballs,SceneE7River,SceneE2Blacknight


* this plays a single scene in R1. If it's game over, then it
* does not return, otherwise it returns when the scene is over
* (success or failure)
ALREADYSCENE
* remember our caller
	MOV R11,@save4

* scene page to play is in R1 - first add it to the VDP replay queue
* but if we live, we'll forget about it
	MOV @REPLAYQ,R0		* copy it to VDP
	BL @VDPW16			* non-destructive

* now play it
	MOV R1,R3			* move scene number to R3
	LI R1,>601C			* all scenes start at >601C
	BL @TRAMPRET		* go call it
	
* We're back!!
* check if this was a death scene
	movb @justdied,r0
	jeq DONEALREADY
	
* yep, player died, so decrement and check for remaining lives...
* (the ressurrection sequence does the display)
	sb @byte01,@lives
	jne DONEDIED		* not game over yet!
	
* it /is/ game over, the player done bit the big one
* show the newly zeroed lives
	bl @showlives

* play the game over scene... (scene helpfully gave us the data in R14/R15)
	clr JOYMASK			* no input
	mov R14,r8			* starting page of death scene
	mov R15,r7			* number of frames
	BL @CALLVIDEO
	
* now show the gameover screen for a few seconds
	li r0,>2a50
	li r1,240
	bl @showandpause
	
* and loop back around to the attract mode
	b @attract
	
* player died, so increment the replay scene queue to remember this one
DONEDIED
	inct @REPLAYQ
	
* display a brief black frame for a more comfortable transition to the next ressurection
	bl @blackvid		* in case we didn't get all the way to black
	li r13,40			* 123 second (note: fire button can cancel, should be okay)
	bl @delay

* and back to caller
DONEALREADY
	mov @save4,r11
	B *R11

* BCD lookup table for digits (top half only, bottom half add 32)
* each value from 0-99 returns a word representing two digits
BCDLOOKUP
	DATA >A7A7,>A7A8,>A7A9,>A7AA,>A7AB,>A7AC
	DATA >A7AD,>A7AE,>A7AF,>A7B0,>A8A7,>A8A8
	DATA >A8A9,>A8AA,>A8AB,>A8AC,>A8AD,>A8AE
	DATA >A8AF,>A8B0,>A9A7,>A9A8,>A9A9,>A9AA
	DATA >A9AB,>A9AC,>A9AD,>A9AE,>A9AF,>A9B0
	DATA >AAA7,>AAA8,>AAA9,>AAAA,>AAAB,>AAAC
	DATA >AAAD,>AAAE,>AAAF,>AAB0,>ABA7,>ABA8
	DATA >ABA9,>ABAA,>ABAB,>ABAC,>ABAD,>ABAE
	DATA >ABAF,>ABB0,>ACA7,>ACA8,>ACA9,>ACAA
	DATA >ACAB,>ACAC,>ACAD,>ACAE,>ACAF,>ACB0
	DATA >ADA7,>ADA8,>ADA9,>ADAA,>ADAB,>ADAC
	DATA >ADAD,>ADAE,>ADAF,>ADB0,>AEA7,>AEA8
	DATA >AEA9,>AEAA,>AEAB,>AEAC,>AEAD,>AEAE
	DATA >AEAF,>AEB0,>AFA7,>AFA8,>AFA9,>AFAA
	DATA >AFAB,>AFAC,>AFAD,>AFAE,>AFAF,>AFB0
	DATA >B0A7,>B0A8,>B0A9,>B0AA,>B0AB,>B0AC
	DATA >B0AD,>B0AE,>B0AF,>B0B0
	
* these are just really handy...
BYTE00
	BYTE >00
BYTE01
	BYTE >01
BYTE02
	BYTE >02
BYTE03
	BYTE >03
BYTEFF
	BYTE >FF
	
	EVEN
QUITK        
    DATA >1100

    END
    